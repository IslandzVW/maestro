#!/usr/bin/env python
# encoding: utf-8
'''
RestConsole -- Implements a remote console using Rest to the OpenSim Services

@author:     Mike Dickson
@copyright:  2013 InWorldz, LLC. All rights reserved.
@license:    Unreleased
@contact:    mike.chase@alternatemetaverse.com
'''

import sys
import os
import urllib, urllib2
import xml.dom.minidom

from optparse import OptionParser

__all__ = []
__version__ = "0.1"
__date__ = '2013-05-14'
__updated__ = '2014-02-13'

DEBUG = 0
TESTRUN = 0
PROFILE = 0

class ConsoleClient:

    def __init__(self, addr, username, password):
        self.addr = addr
        url = self.addr + 'StartSession/'

        params = urllib.urlencode({
            'USER': username,       # REST username
            'PASS': password        # REST password
        })
        data = urllib2.urlopen(url, params).read()

        dom = xml.dom.minidom.parseString(data)
        elem =  dom.getElementsByTagName('SessionID')
        self.sessionid = elem[0].childNodes[0].nodeValue
        elem = dom.getElementsByTagName('Prompt')
        self.prompt = elem[0].childNodes[0].nodeValue + '# '

    def close(self):
        url = self.addr + 'CloseSession/'
        params = urllib.urlencode({
            'ID': self.sessionid
        })
        print urllib2.urlopen(url, params).read()

    def do_cmd(self, cmd):
        url = self.addr + 'SessionCommand/'
        params = urllib.urlencode({
            'ID': self.sessionid,
            'COMMAND': cmd
        })
        data = urllib2.urlopen(url, params).read()
        dom = xml.dom.minidom.parseString(data)
        elem =  dom.getElementsByTagName('Result')
        return elem[0].childNodes[0].nodeValue

    def read_buffer(self):
        url = self.addr + 'ReadResponses/' + self.sessionid + '/'
        params = urllib.urlencode({
            'ID': self.sessionid
        })

        result = urllib2.urlopen(url, params).read()
        dom = xml.dom.minidom.parseString(result)

        elem =  dom.getElementsByTagName('Line')
        for line in elem:
            x0 = line.childNodes[0].nodeValue
            x1 = str.replace(str(x0),':','~',2)
            x2 = x1.split("~")
            for lv in x2[2:]:
                if not '+++' in lv:
                    print lv



def main(argv=None):
    '''Command line options.'''

    program_name = os.path.basename(sys.argv[0])
    program_version = __version__
    program_build_date = "%s" % __updated__

    program_version_string = '%%prog %s (%s)' % (program_version, program_build_date)
    #program_usage = '''usage: spam two eggs''' # optional - will be autogenerated by optparse
    program_longdesc = '''''' # optional - give further explanation about what the program does
    program_license = "Copyright 2013 user_name (organization_name)                                            \
                Licensed under the Apache License 2.0\nhttp://www.apache.org/licenses/LICENSE-2.0"

    if argv is None:
        argv = sys.argv[1:]

    # setup option parser
    parser = OptionParser(version=program_version_string, epilog=program_longdesc, description=program_license)

    parser.add_option("-p", "--password", dest="password", help="The password to use when connecting to the remote agent [default: %default]")
    parser.add_option("-u", "--username", dest="username", help="The username to use when connecting [default: %default]")
    parser.add_option("-i", "--ipaddress", dest="ipaddress", help="The hostname or ipaddress to establish a connection to [default: %default]")
    parser.add_option("-a", "--address", dest="address", help="The Port to connect to [default: %default]")
    parser.add_option("-v", "--verbose", dest="verbose", action="count", help="set verbosity level [default: %default]")

    # set defaults
    parser.set_defaults(password="", username="", ipaddress="127.0.0.1", address="9000", verbose=1)

    # process options
    (opts, args) = parser.parse_args(argv)
    if opts.verbose > 0:
        print("verbosity level = %d" % opts.verbose)

    username = opts.username
    if (username == ""):
        username = raw_input("Username: ")
    password = opts.password
    if ((password == "") or (opts.username == "")):
        import getpass
        password = getpass.getpass("Password: ")
            
    url = "http://{0}:{1}/".format(opts.ipaddress, opts.address)
    if (opts.verbose > 0):
        print "Connecting to %s" % url
                    
    try:
        # set the base url to the REST console (with port)
        console = ConsoleClient(url, username, password)
        
        console.read_buffer()
        print 'quit with a "."'
        cmd = ""
        while cmd != ".":
            if cmd != "":
                if 'OK' in console.do_cmd(cmd):
                    console.read_buffer()
            cmd = raw_input("%s " % console.prompt)

        console.close()

    except Exception, e:
        indent = len(program_name) * " "
        import traceback
        sys.stderr.write(traceback.format_exc())
        sys.stderr.write(indent + "  for help use --help")
        return 2


if __name__ == "__main__":
    if DEBUG:
        sys.argv.append("-h")
    if TESTRUN:
        import doctest
        doctest.testmod()
    if PROFILE:
        import cProfile
        import pstats
        profile_filename = 'RestConsole_profile.txt'
        cProfile.run('main()', profile_filename)
        statsfile = open("profile_stats.txt", "wb")
        p = pstats.Stats(profile_filename, stream=statsfile)
        stats = p.strip_dirs().sort_stats('cumulative')
        stats.print_stats()
        statsfile.close()
        sys.exit(0)
        
    sys.exit(main())